\chapter{Conception et Architecture du Système}

\section{Introduction}

Ce chapitre présente la conception détaillée de notre système de détection d'anomalies pour moteurs industriels. Nous détaillons l'architecture globale, les choix algorithmiques, l'adaptation des méthodes au contexte embarqué, et la stratégie d'optimisation pour respecter les contraintes strictes du TinyML. L'objectif est de démontrer comment nous transformons les concepts théoriques présentés au Chapitre 1 en une solution technique concrète et réalisable.

\section{Architecture Globale du Système}

\subsection{Vue d'Ensemble}

Notre système suit une architecture en pipeline optimisée pour le traitement temps réel sur microcontrôleur :

\begin{figure}[h]
\centering
% Ici sera inséré le diagramme d'architecture
\caption{Architecture globale du système de détection d'anomalies}
\label{fig:architecture_globale}
\end{figure}

Le pipeline se compose de cinq modules principaux :
\begin{enumerate}
    \item \textbf{Module d'Acquisition :} Interface avec le capteur ADXL345 via I2C
    \item \textbf{Module de Buffering :} Gestion optimisée de la mémoire avec double buffer
    \item \textbf{Module de Traitement :} FFT et extraction de caractéristiques
    \item \textbf{Module de Détection :} Algorithme K-means pour classification
    \item \textbf{Module d'Action :} Alertes locales et communication réseau
\end{enumerate}

\subsection{Flux de Données}

Le flux de données est conçu pour minimiser la latence tout en maximisant l'efficacité énergétique :

\begin{enumerate}
    \item Acquisition à 1600 Hz sur 3 axes (X, Y, Z)
    \item Accumulation dans buffer de 2000 points
    \item Fenêtrage (Hanning) et FFT 128 points
    \item Extraction de 32 caractéristiques fréquentielles
    \item Classification K-means avec 5 clusters
    \item Décision et action en <10ms
\end{enumerate}

\section{Module d'Acquisition des Données}

\subsection{Configuration du Capteur ADXL345}

La configuration optimale du capteur a été déterminée expérimentalement :

\begin{lstlisting}[language=C, caption=Configuration ADXL345]
// Configuration registres ADXL345
#define ADXL345_ADDR         0x53
#define ADXL345_POWER_CTL    0x2D
#define ADXL345_DATA_FORMAT  0x31
#define ADXL345_BW_RATE      0x2C
#define ADXL345_FIFO_CTL     0x38

void configureADXL345() {
    // Plage ±16g pour capturer tous les défauts
    writeRegister(ADXL345_DATA_FORMAT, 0x0B);
    
    // Taux d'échantillonnage 1600Hz
    writeRegister(ADXL345_BW_RATE, 0x0E);
    
    // Mode FIFO Stream
    writeRegister(ADXL345_FIFO_CTL, 0x80);
    
    // Activation mesure
    writeRegister(ADXL345_POWER_CTL, 0x08);
}
\end{lstlisting}

\subsection{Stratégie de Double Buffering}

Pour garantir l'acquisition continue sans perte de données :

\begin{lstlisting}[language=C, caption=Double buffering pour acquisition continue]
typedef struct {
    int16_t x[BUFFER_SIZE];
    int16_t y[BUFFER_SIZE];
    int16_t z[BUFFER_SIZE];
    uint32_t timestamp;
    bool ready;
} VibrationBuffer;

VibrationBuffer bufferA, bufferB;
VibrationBuffer* activeBuffer = &bufferA;
VibrationBuffer* processingBuffer = &bufferB;

void swapBuffers() {
    VibrationBuffer* temp = activeBuffer;
    activeBuffer = processingBuffer;
    processingBuffer = temp;
}
\end{lstlisting}

\section{Module de Traitement du Signal}

\subsection{Transformation de Fourier Rapide (FFT)}

L'implémentation FFT est optimisée pour ESP32 :

\begin{itemize}
    \item Utilisation de la bibliothèque ESP-DSP optimisée en assembleur
    \item FFT 128 points pour équilibrer résolution et performance
    \item Fenêtrage de Hanning pour réduire les fuites spectrales
    \item Calcul sur nombres entiers 16-bit pour efficacité
\end{itemize}

\subsection{Extraction de Caractéristiques}

Nous extrayons 32 caractéristiques discriminantes :

\begin{table}[h]
\centering
\caption{Caractéristiques extraites pour la détection d'anomalies}
\begin{tabular}{lcc}
\toprule
\textbf{Domaine} & \textbf{Caractéristique} & \textbf{Nombre} \\
\midrule
\multirow{4}{*}{Temporel} & RMS (3 axes) & 3 \\
                          & Facteur de crête & 3 \\
                          & Kurtosis & 3 \\
                          & Asymétrie (Skewness) & 3 \\
\midrule
\multirow{5}{*}{Fréquentiel} & Énergie par bande (8 bandes) & 8 \\
                              & Fréquence dominante & 3 \\
                              & Amplitude pic principal & 3 \\
                              & Ratio harmoniques & 3 \\
                              & Centroïde spectral & 3 \\
\midrule
\textbf{Total} & & \textbf{32} \\
\bottomrule
\end{tabular}
\end{table}

\section{Module de Détection - Algorithme K-means}

\subsection{Adaptation pour TinyML}

L'algorithme K-means standard est adapté aux contraintes embarquées :

\begin{lstlisting}[language=C, caption=K-means optimisé pour ESP32]
typedef struct {
    float centroid[NUM_FEATURES];
    uint16_t count;
    float radius;
} Cluster;

Cluster clusters[NUM_CLUSTERS];

float euclideanDistance(float* a, float* b, int dim) {
    float sum = 0;
    for(int i = 0; i < dim; i++) {
        float diff = a[i] - b[i];
        sum += diff * diff;
    }
    return sqrtf(sum);
}

int classify(float* features) {
    float minDist = FLT_MAX;
    int bestCluster = -1;
    
    for(int k = 0; k < NUM_CLUSTERS; k++) {
        float dist = euclideanDistance(features, 
                                      clusters[k].centroid, 
                                      NUM_FEATURES);
        if(dist < minDist) {
            minDist = dist;
            bestCluster = k;
        }
    }
    
    // Détection d'anomalie
    if(minDist > clusters[bestCluster].radius * THRESHOLD_FACTOR) {
        return ANOMALY_DETECTED;
    }
    
    return bestCluster;
}
\end{lstlisting}

\subsection{Phase d'Entraînement}

L'entraînement se fait offline sur Edge Impulse avec les étapes suivantes :

\begin{enumerate}
    \item Collection de 10 minutes de données normales
    \item Segmentation en fenêtres de 1.25 secondes
    \item Extraction des 32 caractéristiques par fenêtre
    \item Clustering K-means avec K=5 (déterminé par méthode du coude)
    \item Calcul du rayon de chaque cluster (95e percentile)
    \item Export des centroïdes et rayons vers code C
\end{enumerate}

\section{Optimisations Système}

\subsection{Optimisations Mémoire}

La gestion mémoire est critique sur ESP32 (520KB SRAM) :

\begin{table}[h]
\centering
\caption{Allocation mémoire du système}
\begin{tabular}{lcc}
\toprule
\textbf{Composant} & \textbf{Taille} & \textbf{Pourcentage} \\
\midrule
Buffers acquisition (×2) & 24 KB & 4.6\% \\
Buffer FFT & 4 KB & 0.8\% \\
Modèle K-means & 2.5 KB & 0.5\% \\
Stack système & 8 KB & 1.5\% \\
Heap dynamique & 16 KB & 3.1\% \\
WiFi/Bluetooth & 64 KB & 12.3\% \\
\midrule
\textbf{Total utilisé} & \textbf{118.5 KB} & \textbf{22.8\%} \\
\textbf{Libre} & \textbf{401.5 KB} & \textbf{77.2\%} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Optimisations Performances}

Pour atteindre la latence cible <10ms :

\begin{itemize}
    \item \textbf{Utilisation du deuxième cœur :} Core 0 pour acquisition, Core 1 pour traitement
    \item \textbf{Instructions SIMD :} Exploitation des extensions vectorielles Xtensa
    \item \textbf{Cache optimisé :} Alignement des données critiques sur 32 bytes
    \item \textbf{Priorités interruptions :} I2C haute priorité, WiFi basse priorité
\end{itemize}

\subsection{Optimisations Énergétiques}

Pour maximiser l'autonomie :

\begin{enumerate}
    \item \textbf{Dynamic Frequency Scaling :} 80MHz en veille, 240MHz en traitement
    \item \textbf{Sleep modes :} Light sleep entre acquisitions
    \item \textbf{WiFi intelligent :} Activation uniquement pour alertes
    \item \textbf{Batch processing :} Traitement par lots de 10 échantillons
\end{enumerate}

\section{Interface Utilisateur et Communication}

\subsection{Alertes Locales}

Le système fournit un feedback immédiat via :

\begin{itemize}
    \item \textbf{LED RGB :} Vert (normal), Orange (attention), Rouge (anomalie)
    \item \textbf{Buzzer :} Patterns sonores différenciés par type d'anomalie
    \item \textbf{Afficheur OLED (optionnel) :} Visualisation temps réel des métriques
\end{itemize}

\subsection{Communication Réseau}

Pour l'intégration dans l'infrastructure existante :

\begin{lstlisting}[language=C, caption=Communication MQTT pour alertes]
void sendMQTTAlert(int anomalyType, float severity) {
    StaticJsonDocument<256> doc;
    doc["timestamp"] = getTimestamp();
    doc["device_id"] = DEVICE_ID;
    doc["anomaly_type"] = anomalyType;
    doc["severity"] = severity;
    doc["location"] = MOTOR_LOCATION;
    
    char buffer[256];
    serializeJson(doc, buffer);
    
    mqttClient.publish("maintenance/alerts", buffer);
}
\end{lstlisting}

\section{Stratégie de Validation}

\subsection{Tests Unitaires}

Chaque module est testé individuellement :

\begin{itemize}
    \item \textbf{Acquisition :} Vérification des taux d'échantillonnage et intégrité
    \item \textbf{FFT :} Comparaison avec implémentation de référence MATLAB
    \item \textbf{K-means :} Validation sur datasets synthétiques connus
    \item \textbf{Communication :} Tests de charge et latence réseau
\end{itemize}

\subsection{Tests d'Intégration}

Le système complet est validé via :

\begin{enumerate}
    \item Signaux de test calibrés (générateur de fonctions)
    \item Simulation de défauts mécaniques contrôlés
    \item Tests de robustesse (bruit, interférences)
    \item Validation de la latence end-to-end
\end{enumerate}

\section{Considérations de Sécurité}

\subsection{Sécurité des Données}

Protection des données sensibles :

\begin{itemize}
    \item \textbf{Chiffrement :} AES-128 pour stockage local
    \item \textbf{Communication :} TLS 1.3 pour MQTT et HTTPS
    \item \textbf{Authentication :} Certificats X.509 pour dispositifs
    \item \textbf{Intégrité :} HMAC-SHA256 pour messages critiques
\end{itemize}

\subsection{Sécurité Opérationnelle}

Prévention des fausses alarmes et défaillances :

\begin{itemize}
    \item \textbf{Watchdog timer :} Reset automatique en cas de blocage
    \item \textbf{Validation croisée :} Confirmation sur N échantillons consécutifs
    \item \textbf{Mode dégradé :} Fonctionnement basique si modèle corrompu
    \item \textbf{Logs d'audit :} Traçabilité complète des événements
\end{itemize}

\section{Conclusion du Chapitre}

La conception présentée transforme les concepts théoriques en architecture technique réalisable. L'adaptation de l'algorithme K-means aux contraintes du TinyML, combinée aux optimisations système spécifiques à l'ESP32, permet d'atteindre nos objectifs de performance (<10ms latence) tout en respectant le budget matériel (<50€).

Les choix architecturaux privilégient la simplicité, la robustesse et l'efficacité, essentiels pour un déploiement industriel. La modularité du design facilite les évolutions futures et l'adaptation à différents types de moteurs.

Le chapitre suivant présente l'implémentation concrète de cette architecture, les tests réalisés au laboratoire FSB, et l'analyse détaillée des résultats obtenus sur le moteur Leroy Somer.